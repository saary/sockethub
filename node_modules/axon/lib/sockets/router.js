
/**
 * Module dependencies.
 */

var Socket = require('./sock');
var slice = require('../utils').slice;
var uuid = require('node-uuid');
var Message = require('amp-message');

/**
 * Expose `RouterSocket`.
 */

module.exports = RouterSocket;

/**
 * Initialize a new `RouterSocket`.
 *
 * @api private
 */

function RouterSocket() {
  Socket.call(this);

  this.sockById = {};
}

/**
 * Inherits from `Socket.prototype`.
 */

RouterSocket.prototype.__proto__ = Socket.prototype;

RouterSocket.REGISTER = 'REGISTER';
RouterSocket.REGISTER_FAILURE = 'REGISTER_FAILURE';
RouterSocket.REGISTER_ID_EXISTS = 'REGISTER_ID_EXISTS';
RouterSocket.REGISTER_SUCCESS = 'REGISTER_SUCCESS';
RouterSocket.NOT_FOUND = 'NOT_FOUND';

/**
 * Send `msg` to the peer identified by id.
 *
 * @param {String} id
 * @param {Mixed} msg
 * @api public
 */

RouterSocket.prototype.send = function() {
  throw new Error('routers cannot send messages');
};


/**
 * Handles framed messages emitted from the parser, by
 * default it will go ahead and emit the "message" events on
 * the socket. It attaches the socket id.
 * Detects id frames and emits `id` events on the socket
 *
 * @param {net.Socket} sock
 * @return {Function} closure(msg, mulitpart)
 * @api private
 */

RouterSocket.prototype.onmessage = function(sock){
  var self = this;

  function sendReply() {
    var args = Array.prototype.slice.apply(arguments);
    var sock = args.shift();

    if (sock.writable) {
      sock.write(self.pack(args));
    }
  }

  function handleRegistration(sock, msg) {
    var firstFrame = msg.args[0];
    if (typeof firstFrame === 'object' && typeof firstFrame.id === 'string' && firstFrame.type === RouterSocket.REGISTER) {
      var registeredStatus = RouterSocket.REGISTER_FAILURE;
      var messageId = msg.pop();

      // make sure the socket is not trying to change into a name that already exists
      if (!self.sockById[firstFrame.id])  {
        // remove the previous entry from the lookup table
        if (sock.id) delete self.sockById[sock.id];

        self.sockById[firstFrame.id] = sock;
        sock.id = firstFrame.id;
        registeredStatus = RouterSocket.REGISTER_SUCCESS;
        
        self.emit.apply(self, ['id', sock].concat(msg.args));
      }
      else {
        registeredStatus = RouterSocket.REGISTER_ID_EXISTS;
      }

      sendReply(sock, registeredStatus, messageId);
      return true;
    }

    return false;
  }

  return function(buf){
    var msg = new Message(buf);
    var firstFrame = msg.args[0];
    if (handleRegistration(sock, msg)) {
      return;
    }

    // if this is an unregistered socket, register it under a random id
    if (!sock.id) {
      sock.id = uuid.v4();
      self.sockById[sock.id] = sock;
    }

    self.emit.apply(self, ['message'].concat(msg.args));
    if (self.sockById[firstFrame.id]) {
      // remove the destination address from the message
      msg.args.shift();
      // add the return address to the message
      msg.unshift({id: sock.id})
      
      sendReply.apply(this, [self.sockById[firstFrame.id]].concat(msg.args));
    }
    else {
      var messageId = msg.pop();
      sendReply(sock, { err: RouterSocket.NOT_FOUND}, messageId);
    }
  };
};
